window.SIDEBAR_ITEMS = {"attr":[["after_expiry","A macro for writing a pledge on a function."],["assert_on_expiry","A macro for writing a two-state pledge on a function."],["ensures","A macro for writing a postcondition on a function."],["extern_spec","A macro for specifying external functions."],["ghost_constraint","A macro to add trait bounds on a generic type parameter and specifications which are active only when these bounds are satisfied for a call."],["invariant","A macro for type invariants."],["model","Macro for creating type models."],["print_counterexample","A macro to custamize how a struct or enum should be printed in a counterexample"],["pure","A macro for marking a function as pure."],["refine_trait_spec","A macro for impl blocks that refine trait specifications."],["requires","A macro for writing a precondition on a function."],["trusted","A macro for marking a function as trusted."]],"fn":[["before_expiry","This function is used to evaluate an expression in the context just before the borrows expires."],["exists","Existential quantifier."],["forall","Universal quantifier."],["old","This function is used to evaluate an expression in the “old” context, that is at the beginning of the method call."],["prusti_set_union_active_field",""],["snap","Creates an owned copy of a reference. This should only be used from within ghost code, as it circumvents the borrow checker."],["snapshot_equality","Snapshot, “logical”, or “mathematical” equality. Compares the in-memory representation of two instances of the same type, even if there is no `PartialEq` nor `Copy` implementation. The in-memory representation is constructed recursively: references are followed, unsafe pointers and cells are not. Importantly, addresses are not taken into consideration."]],"macro":[["body_invariant","A macro for writing a loop body invariant."],["closure","A macro for defining a closure with a specification."],["ghost","A macro for defining ghost blocks which will be left in for verification but omitted during compilation."],["map",""],["predicate","A macro for defining a predicate using prusti expression syntax instead of just Rust expressions."],["prusti_assert","A macro for writing assertions using the full prusti specifications"],["prusti_assume","A macro for writing assumptions using prusti syntax"],["seq",""]],"struct":[["Ghost",""],["Int","a mathematical (unbounded) integer type it should not be constructed from running rust code, hence the private unit inside"],["Map","A map type"],["Seq","A sequence type"]]};